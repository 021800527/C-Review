/*
 * 已知一个整数序列A=(a0,a1，...,an-1),其中0<=ai<n(0<=i<n)。若存在ap1 = ap2 = ... = apm = x
 * 且m>n/2(0<=pk<nm1<=k<=m)，则称x为A的主元素。例如A=(0,5,5,3,5,7,5,5),则5为主元素
 * 又如A = (0,5,5,3,5,1,5,7)，则A中没有主元素。假设A中的n个元素保存在一个一维数组中，请设计一个尽可能高效的算法，找出A的主元素。
 * 若存在主元素，则输出该元素；否则输出-1.要求:
 * （1）给出算法的基本设计思想。

（2）根据设计思想，采用C、C++或Java语言描述算法，关键之处给出注释。

（3）说明你所设计算法的时间复杂度和空间复杂度。
 */
/*
 * 给出算法的基本设计思想：算法的策略是从前向后扫描数组元素，标记处出一个可能成为主元素的元素Num.然后重新计数，确认Num是否是主元素
 * 算法可分为以下两步:
 * 1、选取候选的主元素。一次扫描所给数组中的每个整数，将第一个遇到的整数，将第一个遇到的整数Num保存到c中，记录Num的出现次数为1；
 * 若遇到的下一个整数仍等于Num,则计数加1，否则计数减1；当计数减到0时，将遇到的下一个整数保存到c中，计数重新记为1，开始新一轮计数，即从当前位置
 * 开始重复上述过程，直到扫描完全部数组元素。
 * 2、判断c中元素是否是真正的主元素。再次扫描该数组，统计c中元素出现的次数，若大于n/2，则为主元素；否则，序列中不存在主元素
 */
#include <iostream>
using namespace std;
int Majority(int A[],int n){
    /*
     * 用c来保存候选主元素,count用来计数
     */
    int i ,c ,count = 1;
    /*
     * 设置A[0]为主元素
     */
    c = A[0];
    /*
     * 查找候选主元素
     */
    for (i = 1;  i< n; i++) {
        /*
         * 对A中的候选主元素计数
         */
        if (A[i] == c)
            count++;
        else
            /*
             * 处理不是主元素的情况
             */
        if (count > 0)
            count--;
            /*
             * 更换候选主元素，重新计数
             */
        else {
            c = A[i];
            count = 1;
        }
        cout<<c<<endl;
    }
    if (count > 0)
        /*
         * 统计候选主元素的实际出现次数
         */
        for (i = count = 0;i<n;i++)
            if (A[i]==c)
                count++;
            /*
             * 确认候选主元素
             */
    if (count>n/2) return c;
    else
        /*
         * 不存在主元素
         */
        return -1;
}
int main(){
    int a[8] = {0,5,1,5,0,5,0,5};
    cout<<Majority(a,8);
}